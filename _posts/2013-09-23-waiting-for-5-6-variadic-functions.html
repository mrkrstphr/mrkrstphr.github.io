---
layout: post
title: ! 'Waiting for 5.6: Variadic Functions'
categories:
- Programming
- Waiting For
tags:
- '5.6'
- features
- functions
- PHP
- variadic
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _jd_tweet_this: 'yes'
  _wp_jd_target: http://leftofreality.net/2013/09/23/waiting-for-5-6-variadic-functions/
  _wp_jd_goo: http://goo.gl/B9meeS
  _jd_wp_twitter: ! 'a:1:{i:0;s:58:"Waiting for 5.6: Variadic Functions - http://goo.gl/B9meeS";}'
---
An <a href="https://wiki.php.net/rfc/variadics">RFC for Variadic Functions</a> has been <a href="https://wiki.php.net/rfc/variadics#vote">voted on and accepted</a> by PHP developers, and should make it into the next release (5.6). 

Variadic functions are ones that accept a variable, or infinite, amount of arguments. There are already internal functions in PHP that support this (as C does), such as <code>sprintf</code> where you can pass it any number of arguments. 

{% highlight php startinline %}
sprintf($format, $arg1, $arg2, $arg3);
{% endhighlight %}

Currently, if you wanted to support this in a user-land PHP function or method, you'd have to use the <code>func_get_args()</code> family of functions to determine what was passed beyond the definition. Now, with this accepted RFC, you can define a function like follows (stolen straight from the RFC):

{% highlight php startinline %}
public function query($query, ...$params) {
    $stmt = $this->pdo->prepare($query);
    $stmt->execute($params);
    return $stmt;
}
{% endhighlight %}

<code>$params</code> will be an array of every additional argument passed to that method. 

Checkout the RFC for more examples and details.

<small>* The idea for the "Waiting for..." posts graciously stolen from <a href="http://www.depesz.com/">depesz</a>. Checkout his fantastic PostgreSQL blog.</small>
